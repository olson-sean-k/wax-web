{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Wax is a Rust library that provides opinionated and portable globs that can be matched against file paths and directory trees. Globs use a familiar syntax and support expressive features with semantics that emphasize component boundaries.</p> <p>Warning</p> <p>Wax is under active development and its features and glob expression syntax may change.</p> <p>Unlike many other tools, globs in Wax are completely distinct from paths and are designed for portability (that is, not only is the code for Wax portable, so too are glob expressions). While globs represent regular patterns, they are typically designed specifically for file paths and Wax incorporates this into the design of expressions.</p> <p>For more about the syntax and features of glob expressions and how to use them, see the user guide. To learn more about how to write code against Wax, see the code guide and the API documentation. For contributing changes to Wax, see the contributor guide.</p>"},{"location":"license/","title":"License","text":"<p>Wax is distributed under the MIT license.</p> <p>Copyright \u00a9 2021 - 2023 Sean Olson</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"code-guide/glob/","title":"Glob","text":""},{"location":"code-guide/glob/#basic-usage","title":"Basic Usage","text":"<p>Match a path against a glob:</p> <pre><code>use wax::{Glob, Pattern};\n\nlet glob = Glob::new(\"*.png\").unwrap();\nassert!(glob.is_match(\"logo.png\"));\n</code></pre> <p>Match a path against a glob with matched text (captures):</p> <pre><code>use wax::{CandidatePath, Glob, Pattern};\n\nlet glob = Glob::new(\"**/{*.{go,rs}}\").unwrap();\n\nlet path = CandidatePath::from(\"src/main.go\");\nlet matched = glob.matched(&amp;path).unwrap();\n\nassert_eq!(\"main.go\", matched.get(2).unwrap());\n</code></pre> <p>Match a directory tree against a glob:</p> <pre><code>use wax::Glob;\n\nlet glob = Glob::new(\"**/*.{md,txt}\").unwrap();\nfor entry in glob.walk(\"doc\") {\n    let entry = entry.unwrap();\n    // ...\n}\n</code></pre> <p>Match a directory tree against a glob with negations:</p> <pre><code>use wax::{Glob, LinkBehavior};\n\nlet glob = Glob::new(\"**/*.{md,txt}\").unwrap();\nfor entry in glob\n    .walk_with_behavior(\"doc\", LinkBehavior::ReadTarget)\n    .not([\"**/secret/**\"])\n    .unwrap()\n{\n    let entry = entry.unwrap();\n    // ...\n}\n</code></pre> <p>Match a path against multiple globs:</p> <pre><code>use wax::{Glob, Pattern};\n\nlet any = wax::any([\n    \"src/**/*.rs\",\n    \"tests/**/*.rs\",\n    \"doc/**/*.md\",\n    \"pkg/**/PKGBUILD\",\n]).unwrap();\nassert!(any.is_match(\"src/token/mod.rs\"));\n</code></pre>"},{"location":"contributor-guide/tools-and-hosting/","title":"Tools and Hosting","text":"<p>Both the code and documentation repositories for Wax are hosted on GitHub.</p> <p>Wax is developed, built, and tested using the latest stable release of Rust. It is also tested on the MSRV, stable, beta, and nightly release channels using GitHub Actions. Code is formatted using the nightly build of <code>rustfmt</code>.</p> <p>Please see the contribution documentation in each repository for more details.</p>"},{"location":"user-guide/syntax/","title":"Syntax and Features","text":"<p>Glob expressions resemble Unix paths, but are distinct from paths and support patterns that can be matched against file paths and directory trees (i.e., search). Pattern syntax is similar to that found in Unix shells and tools like <code>git</code>, though there are some important differences.</p> <p>Info</p> <p>Glob expressions are not paths (nor are they \"paths but with meta characters\"). Glob expressions are a distinct language with a consistent syntax on all platforms and do not support all native path features.</p> <p>Here's an example of a glob expression:</p> <pre><code>**/*.{go,rs}\n</code></pre> <p>This glob matches any path with a final component ending with <code>.go</code> or <code>.rs</code>, such as <code>./wax/src/lib.rs</code> or <code>glob.go</code>.</p> <p>Glob syntax is opinionated and is not configurable. For example, with the exception of tree wildcards, patterns never match across component boundaries (separators) and cannot be configured to do so.</p>"},{"location":"user-guide/syntax/#wildcards","title":"Wildcards","text":"<p>Wildcards match some amount of arbitrary text in paths and are the most fundamental pattern provided by globs (and likely the most familiar).</p> <p>The zero-or-more wildcards <code>*</code> and <code>$</code> match zero or more of any character within a component (never path separators). Zero-or-more wildcards cannot be adjacent to other zero-or-more wildcards. The <code>*</code> wildcard is eager and will match the longest possible text while the <code>$</code> wildcard is lazy and will match the shortest possible text. When followed by a literal, <code>*</code> stops at the last occurrence of that literal while <code>$</code> stops at the first occurence.</p> <p>The exactly-one wildcard <code>?</code> matches any single character within a component (never path separators). Exactly-one wildcards do not group automatically, so a pattern of contiguous wildcards such as <code>???</code> form distinct captures for each <code>?</code> wildcard. An alternative can be used to group exactly-one wildcards into a single capture, such as <code>{???}</code>.</p> <p>The tree wildcard <code>**</code> matches any characters across zero or more components. This is the only pattern that implicitly matches across arbitrary component boundaries; all other patterns do not implicitly match across component boundaries. When a tree wildcard participates in a match and does not terminate the pattern, its captured text includes the trailing separator. If a tree wildcard does not participate in a match, then its captured text is an empty string.</p> <p>Tree wildcards must be delimited by forward slashes or terminations (the beginning and/or end of an expression). Tree wildcards and path separators are distinct and any adjacent forward slashes that form a tree wildcard are parsed together. Rooting forward slashes in tree wildcards are meaningful and the glob expressions <code>**/*.txt</code> and <code>/**/*.txt</code> differ in that the former is relative (has no root) and the latter has a root.</p> <p>If a glob expression consists solely of a tree wildcard, then it matches any and all paths and the complete contents of any and all directory trees, including the root.</p>"},{"location":"user-guide/syntax/#character-classes","title":"Character Classes","text":"<p>Character classes match any single character from a group of literals and ranges within a component (never path separators). Classes are delimited by square brackets <code>[...]</code>. Individual character literals are specified as is, such as <code>[ab]</code> to match either <code>a</code> or <code>b</code>. Character ranges are formed from two characters separated by a hyphen, such as <code>[x-z]</code> to match <code>x</code>, <code>y</code>, or <code>z</code>. Character classes match characters exactly and are always case-sensitive, so the expressions <code>[ab]</code> and <code>{a,b}</code> are not necessarily the same.</p> <p>Any number of character literals and ranges can be used within a single character class. For example, <code>[qa-cX-Z]</code> matches any of <code>q</code>, <code>a</code>, <code>b</code>, <code>c</code>, <code>X</code>, <code>Y</code>, or <code>Z</code>.</p> <p>Character classes may be negated by including an exclamation mark <code>!</code> at the beginning of the class pattern. For example, <code>[!a]</code> matches any character except for <code>a</code>. These are the only patterns that support negation.</p> <p>It is possible to escape meta-characters like <code>*</code>, <code>$</code>, etc., using character classes though globs also support escaping via a backslash <code>\\</code>. To match the control characters <code>[</code>, <code>]</code>, and <code>-</code> within a character class, they must be escaped via a backslash, such as <code>[a\\-]</code> to match <code>a</code> or <code>-</code>.</p> <p>Character classes have notable platform-specific behavior, because they match arbitrary characters in native paths but never match path separators. This means that if a character class consists of only path separators on a given platform, then the character class is considered empty and matches nothing. For example, in the expression <code>a[/]b</code> the character class <code>[/]</code> matches nothing on Unix and Windows. Such character classes are not rejected, because the role of arbitrary characters depends on the platform. In practice, this is rarely a concern, but such patterns should be avoided.</p> <p>Character classes have limited utility on their own, but compose well with repetitions.</p>"},{"location":"user-guide/syntax/#alternatives","title":"Alternatives","text":"<p>Alternatives match an arbitrary sequence of one or more comma separated sub-globs delimited by curly braces <code>{...,...}</code>. For example, <code>{a?c,x?z,foo}</code> matches any of the sub-globs <code>a?c</code>, <code>x?z</code>, or <code>foo</code>. Alternatives may be arbitrarily nested and composed with repetitions.</p> <p>Alternatives form a single capture group regardless of the contents of their sub-globs. This capture is formed from the complete match of the sub-glob, so if the alternative <code>{a?c,x?z}</code> matches <code>abc</code>, then the captured text will be <code>abc</code> (not <code>b</code>). Alternatives can be used to group captures using a single sub-glob, such as <code>{*.{go,rs}}</code> to capture an entire file name with a particular extension or <code>{???}</code> to group a sequence of exactly-one wildcards.</p> <p>Alternatives must consider adjacency rules and neighboring patterns. For example, <code>*{a,b*}</code> is allowed but <code>*{a,*b}</code> is not. Additionally, they may not contain a sub-glob consisting of a singular tree wildcard <code>**</code> and cannot root a glob expression as this could cause the expression to match or walk overlapping trees.</p>"},{"location":"user-guide/syntax/#repetitions","title":"Repetitions","text":"<p>Repetitions match a sub-glob a specified number of times. Repetitions are delimited by angle brackets with a separating colon <code>&lt;...:...&gt;</code> where a sub-glob precedes the colon and an optional bounds specification follows it. For example, <code>&lt;a*/:0,&gt;</code> matches the sub-glob <code>a*/</code> zero or more times. Though not implicit like tree wildcards, repetitions can match across component boundaries (and can themselves include tree wildcards). Repetitions may be arbitrarily nested and composed with alternatives.</p> <p>Bound specifications are formed from inclusive lower and upper bounds separated by a comma <code>,</code>, such as <code>:1,4</code> to match between one and four times. The upper bound is optional and may be omitted. For example, <code>:1,</code> matches one or more times (note the trailing comma <code>,</code>). A singular bound is convergent, so <code>:3</code> matches exactly three times (both the lower and upper bounds are three). If no lower or upper bound is specified, then the sub-glob matches one or more times, so <code>&lt;a:&gt;</code> and <code>&lt;a:1,&gt;</code> are equivalent. Similarly, if the colon <code>:</code> is also omitted, then the sub-glob matches zero or more times, so <code>&lt;a&gt;</code> and <code>&lt;a:0,&gt;</code> are equivalent.</p> <p>Repetitions form a singular capture group regardless of the contents of their sub-glob. The capture is formed from the complete match of the sub-glob. If the repetition <code>&lt;abc/&gt;</code> matches <code>abc/abc/</code>, then the captured text will be <code>abc/abc/</code>.</p> <p>Repetitions compose well with character classes. Most often, a glob expression like <code>{????}</code> is sufficient, but the more specific expression <code>&lt;[0-9]:4&gt;</code> further constrains the matched characters to digits, for example. Repetitions may also be more terse, such as <code>&lt;?:8&gt;</code>. Furthermore, repetitions can form tree expressions that further constrain components, such as <code>&lt;[!.]*/&gt;[!.]*</code> to match paths that contain no leading dots <code>.</code> in any component.</p> <p>Repetitions must consider adjacency rules and neighboring patterns. For example, <code>a/&lt;b/**:1,&gt;</code> is allowed but <code>&lt;a/**:1,&gt;/b</code> is not. Additionally, they may not contain a sub-glob consisting of a singular separator <code>/</code>, a singular zero-or-more wildcard <code>*</code> or <code>$</code>, nor a singular tree wildcard <code>**</code>. Repetitions with a lower bound of zero may not root a glob expression, as this could cause the expression to match or walk overlapping trees.</p>"},{"location":"user-guide/syntax/#flags-and-case-sensitivity","title":"Flags and Case Sensitivity","text":"<p>Flags toggle the matching behavior of globs. Importantly, flags are a part of a glob expression rather than an API or behavior specific to an application. Behaviors are toggled immediately following flags in the order in which they appear in glob expressions. Flags are delimited by parenthesis with a leading question mark <code>(?...)</code> and may appear anywhere within a glob expression so long as they do not split tree wildcards (e.g., <code>a/*(?i)*</code> is not allowed). Each flag is represented by a single character and can be negated by preceding the corresponding character with a minus <code>-</code>. Flags are toggled in the order in which they appear within <code>(?...)</code>.</p> <p>The only supported flag is the case-insensitivty flag <code>i</code>. By default, glob expressions use the same case sensitivity as the target platforms's file system APIs (case-sensitive on Unix and case-insensitive on Windows), but <code>i</code> can be used to toggle this explicitly as needed. For example, <code>(?-i)photos/**/*.(?i){jpg,jpeg}</code> matches file paths beneath a <code>photos</code> directory with a case-sensitive base and a case-insensitive extension <code>jpg</code> or <code>jpeg</code>.</p>"}]}